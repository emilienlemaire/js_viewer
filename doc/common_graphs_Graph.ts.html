<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>common/graphs/Graph.ts - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Graph.html">Graph</a><ul class='methods'><li data-type='method'><a href="Graph.html#_getAncestors">_getAncestors</a></li><li data-type='method'><a href="Graph.html#_toEdge">_toEdge</a></li><li data-type='method'><a href="Graph.html#_toNode">_toNode</a></li><li data-type='method'><a href="Graph.html#_toSubsumedEdge">_toSubsumedEdge</a></li><li data-type='method'><a href="Graph.html#addGraphLibNode">addGraphLibNode</a></li><li data-type='method'><a href="Graph.html#addSubsumedEdge">addSubsumedEdge</a></li><li data-type='method'><a href="Graph.html#ancestors">ancestors</a></li><li data-type='method'><a href="Graph.html#getEdges">getEdges</a></li><li data-type='method'><a href="Graph.html#node">node</a></li><li data-type='method'><a href="Graph.html#targetEdges">targetEdges</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-common_displayGraph.html">common/displayGraph</a><ul class='methods'><li data-type='method'><a href="module-common_displayGraph.html#~displayNewGraph">displayNewGraph</a></li></ul></li><li><a href="module-common_draw.html">common/draw</a><ul class='methods'><li data-type='method'><a href="module-common_draw.html#~colorToHex">colorToHex</a></li><li data-type='method'><a href="module-common_draw.html#~drawArrow">drawArrow</a></li><li data-type='method'><a href="module-common_draw.html#~drawHover">drawHover</a></li><li data-type='method'><a href="module-common_draw.html#~drawNode">drawNode</a></li></ul></li><li><a href="module-common_graphs.html">common/graphs</a><ul class='methods'><li data-type='method'><a href="module-common_graphs.html#~getD3Hierachy">getD3Hierachy</a></li><li data-type='method'><a href="module-common_graphs.html#~getGraphNoSubsumed">getGraphNoSubsumed</a></li><li data-type='method'><a href="module-common_graphs.html#~makeHierarchyGraph">makeHierarchyGraph</a></li></ul></li><li><a href="module-common_init.html">common/init</a><ul class='methods'><li data-type='method'><a href="module-common_init.html#~initGraph">initGraph</a></li><li data-type='method'><a href="module-common_init.html#~initNodeGraphics">initNodeGraphics</a></li><li data-type='method'><a href="module-common_init.html#~initPIXI">initPIXI</a></li></ul></li><li><a href="module-common_pixi.html">common/pixi</a></li><li><a href="module-components_Graph.html">components/Graph</a><ul class='methods'><li data-type='method'><a href="module-components_Graph.html#~Graph">Graph</a></li></ul></li><li><a href="module-components_Graph_ContextMenu.html">components/Graph/ContextMenu</a><ul class='methods'><li data-type='method'><a href="module-components_Graph_ContextMenu.html#~ContextMenu">ContextMenu</a></li></ul></li><li><a href="module-components_Main.html">components/Main</a><ul class='methods'><li data-type='method'><a href="module-components_Main.html#~Main">Main</a></li><li data-type='method'><a href="module-components_Main.html#~OptionalGraph">OptionalGraph</a></li></ul></li><li><a href="module-components_TopAppBar.html">components/TopAppBar</a><ul class='methods'><li data-type='method'><a href="module-components_TopAppBar.html#~TopAppBar">TopAppBar</a></li></ul></li><li><a href="module-components_TopAppBar_Dropzone.html">components/TopAppBar/Dropzone</a><ul class='methods'><li data-type='method'><a href="module-components_TopAppBar_Dropzone.html#~Dropzone">Dropzone</a></li></ul></li><li><a href="module-hooks_useD3.html">hooks/useD3</a><ul class='methods'><li data-type='method'><a href="module-hooks_useD3.html#~useD3">useD3</a></li></ul></li><li><a href="module-icons_Cross.html">icons/Cross</a><ul class='methods'><li data-type='method'><a href="module-icons_Cross.html#~CrossIcon">CrossIcon</a></li></ul></li><li><a href="module-icons_More.html">icons/More</a><ul class='methods'><li data-type='method'><a href="module-icons_More.html#~MoreVerticalIcon">MoreVerticalIcon</a></li></ul></li><li><a href="module-index.html">index</a><ul class='methods'><li data-type='method'><a href="module-index.html#~App">App</a></li></ul></li><li><a href="module-store_contextMenu_contextMenuSlice.html">store/contextMenu/contextMenuSlice</a></li><li><a href="module-store_dot_dotSlice.html">store/dot/dotSlice</a></li><li><a href="module-store_graph_GraphSlice.html">store/graph/GraphSlice</a></li><li><a href="module-store_options_optionsSlice.html">store/options/optionsSlice</a><ul class='methods'><li data-type='method'><a href="module-store_options_optionsSlice.html#~checkIndex">checkIndex</a></li><li data-type='method'><a href="module-store_options_optionsSlice.html#~checkShowAllNodes">checkShowAllNodes</a></li></ul></li><li><a href="module-store_selection_selectionSlice.html">store/selection/selectionSlice</a></li></ul><h3>Global</h3><ul><li><a href="global.html#GraphSplit">GraphSplit</a></li><li><a href="global.html#onBackgroundClick">onBackgroundClick</a></li><li><a href="global.html#onHover">onHover</a></li><li><a href="global.html#onNodeClick">onNodeClick</a></li><li><a href="global.html#onOut">onOut</a></li><li><a href="global.html#onTicked">onTicked</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">common/graphs/Graph.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * src/common/graphs/Graph.ts
 * Copyright (c) 2021 Emilien Lemaire &lt;emilien.lem@icloud.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Edge as EdgeType, Graph as GraphType } from "graphlib";
import type { HierarchyPointNode } from "d3";
import type { Edge as CubicleEdge } from "../../types/CubicleGraph";
import type { Edge as StoreEdge } from "../../types/Store";
import type { HierarchyGraph, Node, Edge } from "../../types/Graph";

import {
  Text,
  Graphics,
} from "../../common/pixi";


/**
 * The graph class that is used to draw the graph.
 *
 * @remarks
 * The graph generated by this class is referred as `the graph`. The one built by parsing the
 *      .dot file is referred as `the original graph`.
 */
export class Graph {

  readonly graph: GraphType;

  readonly root: Node;

  readonly nodes: Node[] = [];

  readonly edges: Edge[];

  private _nodeMap = new Map&lt;string, Node>();

  private _edgeMap = new Map&lt;StoreEdge, Edge>();

  private _topLevelX = 50;

  private _parents = new Map&lt;string, Node[]>();

  private _sourceMap = new Map&lt;string, Edge[]>();

  private _targetMap = new Map&lt;string, Edge[]>();


  /**
  * Creates a graph.
   * @param {HierarchyPointNode&lt;HierarchyGraph>} root - The d3 representation of the graph.
   * @param {GraphType} nodes - The graphlib reprensentation of the graph.
   * @param {EdgeType[]} edges - An array of edges in graphlib representation.
  */
  constructor(
    root: HierarchyPointNode&lt;HierarchyGraph>,
    nodes: GraphType,
    edges: EdgeType[]
  ) {
    // We save the graphlib representation for future usage.
    this.graph = nodes;

    // WE get our custom node reprensentation of the root and then of all the descendants.
    this.root = this._toNode(root);
    root.descendants().forEach((n) => {
      this._toNode(n);
    });
    // We get the custom edges representations of the edges.
    this.edges = edges.reduce((acc: Edge[], e: EdgeType): Edge[] => {
      const edge = this._toEdge(e);
      if ( edge ) {
        acc.push(edge);
        return acc;
      }
      return acc;
    }, []);

    // We set our nodes array from the map we just filled.
    this.nodes = Array.from(this._nodeMap.values());
  }

  /**
   * Create a graph node from a hierarchy node.
   *
   * @param {HierarchyPointNode&lt;HierarchyGraph>} node - The hierarchy node that needs to be transformed
   * @return {Node} The transformed node.
   */
  private _toNode(node: HierarchyPointNode&lt;HierarchyGraph>): Node {
    // If we already have this node in the graph no need to add it again.
    if (!this._nodeMap.has(node.data.name)) {
      // We create the new node object
      const newNode = {
        name: node.data.name,
        label: node.data.data.label as string,
        color: node.data.data.color,
        x: node.x,
        y: node.y,
        text: new Text(node.data.data.label as string),
        gfx: new Graphics(),
        children: (node.children || []).map((n) => this._toNode(n)),
        graph: this,
      };
      // We add it to the node map.
      this._nodeMap.set(node.data.name, newNode);
      return newNode;
    }
    return &lt;Node> this._nodeMap.get(node.data.name);
  }

  /**
   * Create a graph edge from basic edge type.
   *
   * @param {EdgeType} edge - The edge to be transformed
   * @return {Edge | undefined} The transformed edge.
   */
  private _toEdge(edge: EdgeType): Edge | undefined {
    const e = this.graph.edge(edge);

    // If the nodes connected by this edge are not in the graph, we don't add it.
    if (!this._nodeMap.has(edge.w) || !this._nodeMap.has(edge.v)) {
      return;
    }

    // We fill the parents map of the target node of the new edge.
    this._parents.set(edge.w, (() => {
      const actual_parents = this._parents.get(edge.w) || [];
      const new_parent = &lt;Node> this._nodeMap.get(edge.v);
      return [...actual_parents, new_parent];
    })());

    // We get the source and target nodes from the maps
    const source = &lt;Node> this._nodeMap.get(edge.v);
    const target = &lt;Node> this._nodeMap.get(edge.w);

    const newEdge = {
      source,
      target,
      ...e,
    };

    // We had the edge to the source map of the source node
    const actual_source = &lt;Edge[]> this._sourceMap.get(source.name) || [];
    this._sourceMap.set(source.name, [...actual_source, newEdge]);

    // We had the edge to the target map of the target node
    const actual_target = &lt;Edge[]> this._targetMap.get(target.name) || [];
    this._targetMap.set(target.name, [...actual_target, newEdge]);

    const edgeLabel = {
      source: edge.v,
      target: edge.w,
    };

    if (!this._edgeMap.has(edgeLabel)) {
      this._edgeMap.set(edgeLabel, newEdge);
    }

    return newEdge;
  }

  /**
   * Create a graph edge that is subsumed.
   *
   * @param {EdgeType} edge - The basic edge to be transformed.
   * @param {CubcicleEdge} data - The data of the edge to be transformed.
   * @return {Edge} A new graph edge that is subsuned, with all the data.
   */
  private _toSubsumedEdge(edge: EdgeType, data: CubicleEdge): Edge {
    const source = &lt;Node> this._nodeMap.get(edge.v);
    const target = &lt;Node> this._nodeMap.get(edge.w);

    return {
      source,
      target,
      ...data,
    };
  }

  /**
   * Look for the node named n in the graph.
   *
   * @param {string} n - The name of the node we are looking for.
   * @return {Node | null} null if the node is not part of the graph, the node itself otherwise.
   */
  node(n: string): Node | null {
    return (this._nodeMap.has(n))
    ? &lt;Node> this._nodeMap.get(n)
    : null;
  }

  /**
   * Adds a node that is contained in the original graph.
   *
   * @param {string} node - The name of the node to be added.
   * @return {Node|undefined} The new node if it can be added
   */
  addGraphLibNode(node: string): Node | undefined {
    if (!this._nodeMap.has(node)) {
      const graphLibNode = this.graph.node(node);
      if (graphLibNode.label) return;

      const newNode: Node = {
        name: node,
        label: `Invariant ${node}`,
        color: "gray",
        x: this._topLevelX,
        y: -20,
        text: new Text(`Invariant ${node}`),
        gfx: new Graphics(),
        graph: this,
      };

      this._nodeMap.set(node, newNode);
      this.nodes.push(newNode);

      return newNode;
    }
    return this._nodeMap.get(node);
  }

  /**
   * Look for the ancestors of the node.
   *
   * @param {Node} node - The node we seek the parets of.
   * @param {Node[]} parents - The parents we already know.
   * @return {Node[]} An array of the ancestors of the node.
   */
  private _getAncestors(node: Node, parents: Node[]): Node[] {
    if (this._parents.has(node.name)) {
      const newParents = &lt;Node[]> this._parents.get(node.name);
      const parentArrays = &lt;Node[]> newParents.flatMap((n) => {
        return this._getAncestors(n, newParents);
      });
      return [...parents, ...parentArrays];
    }
    return [node];
  }

  /**
   * Get the ancestors of the node.
   *
   * @param {Node} node - The node we want to have the ancestors of.
   * @return {Node[]} An array of nodes that are ancestors of the node or an emptay array if the node
   *    does not have any ancestors.
   */
  ancestors(node: Node): Node[] {
    return this._getAncestors(node, []);
  }

  /**
   * Get the edges that targets the nodes.
   *
   * @param {Nodes[]} nodes - The nodes we want the edges that target them.
   * @return {Edge[]} An array of edges or an empty array if none of the nodes in argument are
   *    targeted by any edges.
   */
  targetEdges(nodes: Node[]): Edge[] {
    return nodes.flatMap((n) => {
      return (this._targetMap.has(n.name))
        ? this._targetMap.get(n.name) as Edge[]
        : [];
    });

  }

  /**
   * Add a subsumed edge to the graph.
   *
   * @param edge - A tuple containing the original graph edge and the edge data.
   * @return {Edge} The subsumed edge represented in our custom format.
   */
  addSubsumedEdge(edge: [EdgeType, CubicleEdge]): Edge {
    const newEdge = this._toSubsumedEdge(edge[0], edge[1]);
    this.edges.push(newEdge);
    return newEdge;
  }

  /**
   * Return an array of edges from the selectionState type format to the graph edge type
   *
   * @param {StoreEdge[]} edges - The edeges we are looking to get back.
   * @return {Edge[]} An array of edges or an empty array if no edge are in the graph.
   */
  getEdges(edges: StoreEdge[]): Edge[] {
    return edges.reduce((acc: Edge[], e: StoreEdge): Edge[] => {
      const edge = this._edgeMap.get(e);
      if (edge) {
        acc.push(edge);
        return acc;
      }
      return acc;
    }, []);
  }
}

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Jul 20 2021 15:32:23 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
