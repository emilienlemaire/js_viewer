import type { Edge as EdgeType } from "graphlib";
import type { Edge as CubicleEdge } from "../types/CubicleGraph";
import type { HierarchyGraph, Node, Edge } from "../types/Graph";
import type { Edge as StoreEdge } from "../types/Store";
import type { HierarchyPointNode } from "d3";

import {
  Text,
  Graphics,
} from "pixi.js";
import { Graph as GraphType } from "graphlib";

/**
 * The graph class that is used to draw the graph.
 *
 * @remarks
 * The graph generated by this class is referred as `the graph`. The one built by parsing the
 *      .dot file is referred as `the original graph`.
 */
export class Graph {

  readonly graph: GraphType;

  readonly root: Node;

  readonly nodes: Node[] = [];

  readonly edges: Edge[];

  private _nodeMap = new Map<string, Node>();

  private _edgeMap = new Map<StoreEdge, Edge>();

  private _topLevelX = 50;

  private _parents = new Map<string, Node[]>();

  private _sourceMap = new Map<string, Edge[]>();

  private _targetMap = new Map<string, Edge[]>();


  constructor(
    root: HierarchyPointNode<HierarchyGraph>,
    nodes: GraphType,
    edges: EdgeType[]
  ) {
    this.graph = nodes;
    this.root = this._toNode(root);
    root.descendants().forEach((n) => {
      this._toNode(n);
    });
    this.edges = edges.reduce((acc: Edge[], e: EdgeType): Edge[] => {
      const edge = this._toEdge(e);
      if ( edge ) {
        acc.push(edge);
        return acc;
      }
      return acc;
    }, []);
    this.nodes = Array.from(this._nodeMap.values());
  }

  /**
   * Create a graph node from a hierarchy node.
   *
   * @param node - The hierarchy node that needs to be transformed
   * @returns The transformed node.
   */
  private _toNode(node: HierarchyPointNode<HierarchyGraph>): Node {
    // If we already have this node in the graph no need to add it again.
    if (!this._nodeMap.has(node.data.name)) {
      // We create the new node object
      const newNode = {
        name: node.data.name,
        label: node.data.data.label as string,
        color: node.data.data.color,
        x: node.x,
        y: node.y,
        text: new Text(node.data.data.label as string),
        gfx: new Graphics(),
        children: (node.children || []).map((n) => this._toNode(n)),
        graph: this,
      };
      // We add it to the node map.
      this._nodeMap.set(node.data.name, newNode);
      return newNode;
    }
    return <Node> this._nodeMap.get(node.data.name);
  }

  /**
   * Create a graph edge from basic edge type.
   *
   * @param edge - The edge to be transformed
   * @returns The transformed edge.
   */
  private _toEdge(edge: EdgeType): Edge | undefined {
    const e = this.graph.edge(edge);

    // If the nodes connected by this edge are not in the graph, we don't add it.
    if (!this._nodeMap.has(edge.w) || !this._nodeMap.has(edge.v)) {
      return;
    }

    // We fill the parents map of the target node of the new edge.
    this._parents.set(edge.w, (() => {
      const actual_parents = this._parents.get(edge.w) || [];
      const new_parent = <Node> this._nodeMap.get(edge.v);
      return [...actual_parents, new_parent];
    })());

    // We get the source and target nodes from the maps
    const source = <Node> this._nodeMap.get(edge.v);
    const target = <Node> this._nodeMap.get(edge.w);

    const newEdge = {
      source,
      target,
      ...e,
    };

    // We had the edge to the source map of the source node
    const actual_source = <Edge[]> this._sourceMap.get(source.name) || [];
    this._sourceMap.set(source.name, [...actual_source, newEdge]);

    // We had the edge to the target map of the target node
    const actual_target = <Edge[]> this._targetMap.get(target.name) || [];
    this._targetMap.set(target.name, [...actual_target, newEdge]);

    const edgeLabel = {
      source: edge.v,
      target: edge.w,
    };

    if (!this._edgeMap.has(edgeLabel)) {
      this._edgeMap.set(edgeLabel, newEdge);
    }

    return newEdge;
  }

  /**
   * Create a graph edge that is subsumed.
   *
   * @param edge - The basic edge to be transformed.
   * @param data - The data of the edge to be transformed.
   * @returns A new graph edge that is subsuned, with all the data.
   */
  private _toSubsumedEdge(edge: EdgeType, data: CubicleEdge): Edge {
    const source = <Node> this._nodeMap.get(edge.v);
    const target = <Node> this._nodeMap.get(edge.w);

    return {
      source,
      target,
      ...data,
    };
  }

  /**
   * Look for the node named n in the graph.
   *
   * @param n - The name of the node we are looking for.
   * @returns null if the node is not part of the graph, the node itself otherwise.
   */
  node(n: string): Node | null {
    return (this._nodeMap.has(n))
    ? <Node> this._nodeMap.get(n)
    : null;
  }

  /**
   * Adds a node that is contained in the original graph.
   *
   * @param node - The name of the node to be added.
   * @returns
   */
  addGraphLibNode(node: string): void {
    if (!this._nodeMap.has(node)) {
      const graphLibNode = this.graph.node(node);
      if (graphLibNode.label) return;

      const newNode: Node = {
        name: node,
        label: `Invariant ${node}`,
        color: "gray",
        x: this._topLevelX,
        y: -20,
        text: new Text(`Invariant ${node}`),
        gfx: new Graphics(),
        graph: this,
      };

      this._nodeMap.set(node, newNode);
      this.nodes.push(newNode);
    }
  }

  /**
   * Look for the ancestors of the node.
   *
   * @param node - The node we seek the parets of.
   * @param parents - The parents we already know.
   * @returns
   */
  private _getAncestors(node: Node, parents: Node[]): Node[] {
    if (this._parents.has(node.name)) {
      const newParents = <Node[]> this._parents.get(node.name);
      const parentArrays = <Node[]> newParents.flatMap((n) => {
        return this._getAncestors(n, newParents);
      });
      return [...parents, ...parentArrays];
    }
    return [node];
  }

  /**
   * Get the ancestors of the node.
   *
   * @param node - The node we want to have the ancestors of.
   * @returns An array of nodes that are ancestors of the node or an emptay array if the node
   *    does not have any ancestors.
   */
  ancestors(node: Node): Node[] {
    return this._getAncestors(node, []);
  }

  /**
   * Get the edges that targets the nodes.
   *
   * @param nodes - The nodes we want the edges that target them.
   * @returns An array of edges or an empty array if none of the nodes in argument are
   *    targeted by any edges.
   */
  targetEdges(nodes: Node[]): Edge[] {
    return nodes.flatMap((n) => {
      return (this._targetMap.has(n.name))
        ? this._targetMap.get(n.name) as Edge[]
        : [];
    });

  }

  /**
   * Add a subsumed edge to the graph.
   *
   * @param edge - A tuple containing the original graph edge and the edge data.
   * @returns
   */
  addSubsumedEdge(edge: [EdgeType, CubicleEdge]): void {
    this.edges.push(this._toSubsumedEdge(edge[0], edge[1]));
  }

  /**
   * Return an array of edges from the selectionState type format to the graph edge type
   *
   * @param edges -
   * @returns
   */
  getEdges(edges: StoreEdge[]): Edge[] {
    return edges.reduce((acc: Edge[], e: StoreEdge): Edge[] => {
      const edge = this._edgeMap.get(e);
      if (edge) {
        acc.push(edge);
        return acc;
      }
      return acc;
    }, []);
  }
}

/**
 * makeGraph.
 *
 * @param graph -
 * @param node -
 * @returns
 */
function makeGraph(graph: GraphType, node: string): HierarchyGraph {
  const n = graph.node(node);
  const g: HierarchyGraph = {
    name: node,
    data: n,
  };
  const succ: Array<string> = (graph.successors(node) instanceof Array)
    ? <string[]>(graph.successors(node))
    : [];
  g.children = succ.map((child) => {
    return makeGraph(graph, child);
  });

  return g;
}

/**
 * getD3Hierachy.
 *
 * @param graph -
 * @param root -
 * @returns
 */
export function getD3Hierachy(graph: GraphType, root: GraphType): HierarchyGraph {
  if (root.nodes().length != 1) {
    throw new Error("The root graph must be exactly one element long. It contains "
      + root.nodes().length + " elements.");
  }

  return makeGraph(graph, root.nodes()[0]);
}

/**
 * getGraphNoSubsumed.
 *
 * @param graph -
 * @returns
 */
export function getGraphNoSubsumed(graph: HierarchyGraph): HierarchyGraph {

  const children = (graph.children && !graph.data.subsumed)
    ? graph.children.filter((child) => {
      if(child.data.subsumed) {
        return false;
      }
      return true;
    }).map((child) => {
      return getGraphNoSubsumed(child);
    })
    : undefined;
  const newGraph: HierarchyGraph = {
    children: children,
    data: graph.data,
    name: graph.name,
  };
  return newGraph;
}

